{"ast":null,"code":"'use strict';\n\nlet {\n  SourceMapConsumer,\n  SourceMapGenerator\n} = require('source-map-js');\n\nlet {\n  dirname,\n  resolve,\n  relative,\n  sep\n} = require('path');\n\nlet {\n  pathToFileURL\n} = require('url');\n\nlet Input = require('./input');\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);\nlet pathAvailable = Boolean(dirname && resolve && relative && sep);\n\nclass MapGenerator {\n  constructor(stringify, root, opts, cssString) {\n    this.stringify = stringify;\n    this.mapOpts = opts.map || {};\n    this.root = root;\n    this.opts = opts;\n    this.css = cssString;\n  }\n\n  isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map;\n    }\n\n    return this.previous().length > 0;\n  }\n\n  previous() {\n    if (!this.previousMaps) {\n      this.previousMaps = [];\n\n      if (this.root) {\n        this.root.walk(node => {\n          if (node.source && node.source.input.map) {\n            let map = node.source.input.map;\n\n            if (!this.previousMaps.includes(map)) {\n              this.previousMaps.push(map);\n            }\n          }\n        });\n      } else {\n        let input = new Input(this.css, this.opts);\n        if (input.map) this.previousMaps.push(input.map);\n      }\n    }\n\n    return this.previousMaps;\n  }\n\n  isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline;\n    }\n\n    let annotation = this.mapOpts.annotation;\n\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.inline);\n    }\n\n    return true;\n  }\n\n  isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.withContent());\n    }\n\n    return true;\n  }\n\n  clearAnnotation() {\n    if (this.mapOpts.annotation === false) return;\n\n    if (this.root) {\n      let node;\n\n      for (let i = this.root.nodes.length - 1; i >= 0; i--) {\n        node = this.root.nodes[i];\n        if (node.type !== 'comment') continue;\n\n        if (node.text.indexOf('# sourceMappingURL=') === 0) {\n          this.root.removeChild(i);\n        }\n      }\n    } else if (this.css) {\n      this.css = this.css.replace(/(\\n)?\\/\\*#[\\S\\s]*?\\*\\/$/gm, '');\n    }\n  }\n\n  setSourcesContent() {\n    let already = {};\n\n    if (this.root) {\n      this.root.walk(node => {\n        if (node.source) {\n          let from = node.source.input.from;\n\n          if (from && !already[from]) {\n            already[from] = true;\n            this.map.setSourceContent(this.toUrl(this.path(from)), node.source.input.css);\n          }\n        }\n      });\n    } else if (this.css) {\n      let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>';\n      this.map.setSourceContent(from, this.css);\n    }\n  }\n\n  applyPrevMaps() {\n    for (let prev of this.previous()) {\n      let from = this.toUrl(this.path(prev.file));\n      let root = prev.root || dirname(prev.file);\n      let map;\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new SourceMapConsumer(prev.text);\n\n        if (map.sourcesContent) {\n          map.sourcesContent = map.sourcesContent.map(() => null);\n        }\n      } else {\n        map = prev.consumer();\n      }\n\n      this.map.applySourceMap(map, from, this.toUrl(this.path(root)));\n    }\n  }\n\n  isAnnotation() {\n    if (this.isInline()) {\n      return true;\n    }\n\n    if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.annotation);\n    }\n\n    return true;\n  }\n\n  toBase64(str) {\n    if (Buffer) {\n      return Buffer.from(str).toString('base64');\n    } else {\n      return window.btoa(unescape(encodeURIComponent(str)));\n    }\n  }\n\n  addAnnotation() {\n    let content;\n\n    if (this.isInline()) {\n      content = 'data:application/json;base64,' + this.toBase64(this.map.toString());\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation;\n    } else if (typeof this.mapOpts.annotation === 'function') {\n      content = this.mapOpts.annotation(this.opts.to, this.root);\n    } else {\n      content = this.outputFile() + '.map';\n    }\n\n    let eol = '\\n';\n    if (this.css.includes('\\r\\n')) eol = '\\r\\n';\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n  }\n\n  outputFile() {\n    if (this.opts.to) {\n      return this.path(this.opts.to);\n    } else if (this.opts.from) {\n      return this.path(this.opts.from);\n    } else {\n      return 'to.css';\n    }\n  }\n\n  generateMap() {\n    if (this.root) {\n      this.generateString();\n    } else if (this.previous().length === 1) {\n      let prev = this.previous()[0].consumer();\n      prev.file = this.outputFile();\n      this.map = SourceMapGenerator.fromSourceMap(prev);\n    } else {\n      this.map = new SourceMapGenerator({\n        file: this.outputFile()\n      });\n      this.map.addMapping({\n        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>',\n        generated: {\n          line: 1,\n          column: 0\n        },\n        original: {\n          line: 1,\n          column: 0\n        }\n      });\n    }\n\n    if (this.isSourcesContent()) this.setSourcesContent();\n    if (this.root && this.previous().length > 0) this.applyPrevMaps();\n    if (this.isAnnotation()) this.addAnnotation();\n\n    if (this.isInline()) {\n      return [this.css];\n    } else {\n      return [this.css, this.map];\n    }\n  }\n\n  path(file) {\n    if (file.indexOf('<') === 0) return file;\n    if (/^\\w+:\\/\\//.test(file)) return file;\n    if (this.mapOpts.absolute) return file;\n    let from = this.opts.to ? dirname(this.opts.to) : '.';\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = dirname(resolve(from, this.mapOpts.annotation));\n    }\n\n    file = relative(from, file);\n    return file;\n  }\n\n  toUrl(path) {\n    if (sep === '\\\\') {\n      path = path.replace(/\\\\/g, '/');\n    }\n\n    return encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n  }\n\n  sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.toUrl(this.mapOpts.from);\n    } else if (this.mapOpts.absolute) {\n      if (pathToFileURL) {\n        return pathToFileURL(node.source.input.from).toString();\n      } else {\n        throw new Error('`map.absolute` option is not available in this PostCSS build');\n      }\n    } else {\n      return this.toUrl(this.path(node.source.input.from));\n    }\n  }\n\n  generateString() {\n    this.css = '';\n    this.map = new SourceMapGenerator({\n      file: this.outputFile()\n    });\n    let line = 1;\n    let column = 1;\n    let noSource = '<no source>';\n    let mapping = {\n      source: '',\n      generated: {\n        line: 0,\n        column: 0\n      },\n      original: {\n        line: 0,\n        column: 0\n      }\n    };\n    let lines, last;\n    this.stringify(this.root, (str, node, type) => {\n      this.css += str;\n\n      if (node && type !== 'end') {\n        mapping.generated.line = line;\n        mapping.generated.column = column - 1;\n\n        if (node.source && node.source.start) {\n          mapping.source = this.sourcePath(node);\n          mapping.original.line = node.source.start.line;\n          mapping.original.column = node.source.start.column - 1;\n          this.map.addMapping(mapping);\n        } else {\n          mapping.source = noSource;\n          mapping.original.line = 1;\n          mapping.original.column = 0;\n          this.map.addMapping(mapping);\n        }\n      }\n\n      lines = str.match(/\\n/g);\n\n      if (lines) {\n        line += lines.length;\n        last = str.lastIndexOf('\\n');\n        column = str.length - last;\n      } else {\n        column += str.length;\n      }\n\n      if (node && type !== 'start') {\n        let p = node.parent || {\n          raws: {}\n        };\n\n        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {\n          if (node.source && node.source.end) {\n            mapping.source = this.sourcePath(node);\n            mapping.original.line = node.source.end.line;\n            mapping.original.column = node.source.end.column - 1;\n            mapping.generated.line = line;\n            mapping.generated.column = column - 2;\n            this.map.addMapping(mapping);\n          } else {\n            mapping.source = noSource;\n            mapping.original.line = 1;\n            mapping.original.column = 0;\n            mapping.generated.line = line;\n            mapping.generated.column = column - 1;\n            this.map.addMapping(mapping);\n          }\n        }\n      }\n    });\n  }\n\n  generate() {\n    this.clearAnnotation();\n\n    if (pathAvailable && sourceMapAvailable && this.isMap()) {\n      return this.generateMap();\n    } else {\n      let result = '';\n      this.stringify(this.root, i => {\n        result += i;\n      });\n      return [result];\n    }\n  }\n\n}\n\nmodule.exports = MapGenerator;","map":null,"metadata":{},"sourceType":"script"}