{"ast":null,"code":"import { SelectorType, AttributeAction } from \"./types\";\nconst reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nconst reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nconst actionTypes = new Map([[126\n/* Tilde */\n, AttributeAction.Element], [94\n/* Circumflex */\n, AttributeAction.Start], [36\n/* Dollar */\n, AttributeAction.End], [42\n/* Asterisk */\n, AttributeAction.Any], [33\n/* ExclamationMark */\n, AttributeAction.Not], [124\n/* Pipe */\n, AttributeAction.Hyphen]]); // Pseudos, whose data property is parsed as well.\n\nconst unpackPseudos = new Set([\"has\", \"not\", \"matches\", \"is\", \"where\", \"host\", \"host-context\"]);\n/**\n * Checks whether a specific selector is a traversal.\n * This is useful eg. in swapping the order of elements that\n * are not traversals.\n *\n * @param selector Selector to check.\n */\n\nexport function isTraversal(selector) {\n  switch (selector.type) {\n    case SelectorType.Adjacent:\n    case SelectorType.Child:\n    case SelectorType.Descendant:\n    case SelectorType.Parent:\n    case SelectorType.Sibling:\n    case SelectorType.ColumnCombinator:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]); // Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\n\nfunction funescape(_, escaped, escapedWhitespace) {\n  const high = parseInt(escaped, 16) - 0x10000; // NaN means non-codepoint\n\n  return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n  String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n  String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n}\n\nfunction unescapeCSS(str) {\n  return str.replace(reEscape, funescape);\n}\n\nfunction isQuote(c) {\n  return c === 39\n  /* SingleQuote */\n  || c === 34\n  /* DoubleQuote */\n  ;\n}\n\nfunction isWhitespace(c) {\n  return c === 32\n  /* Space */\n  || c === 9\n  /* Tab */\n  || c === 10\n  /* NewLine */\n  || c === 12\n  /* FormFeed */\n  || c === 13\n  /* CarriageReturn */\n  ;\n}\n/**\n * Parses `selector`, optionally with the passed `options`.\n *\n * @param selector Selector to parse.\n * @param options Options for parsing.\n * @returns Returns a two-dimensional array.\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\n * the second contains the relevant tokens for that selector.\n */\n\n\nexport function parse(selector) {\n  const subselects = [];\n  const endIndex = parseSelector(subselects, `${selector}`, 0);\n\n  if (endIndex < selector.length) {\n    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);\n  }\n\n  return subselects;\n}\n\nfunction parseSelector(subselects, selector, selectorIndex) {\n  let tokens = [];\n\n  function getName(offset) {\n    const match = selector.slice(selectorIndex + offset).match(reName);\n\n    if (!match) {\n      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);\n    }\n\n    const [name] = match;\n    selectorIndex += offset + name.length;\n    return unescapeCSS(name);\n  }\n\n  function stripWhitespace(offset) {\n    selectorIndex += offset;\n\n    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {\n      selectorIndex++;\n    }\n  }\n\n  function readValueWithParenthesis() {\n    selectorIndex += 1;\n    const start = selectorIndex;\n    let counter = 1;\n\n    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n      if (selector.charCodeAt(selectorIndex) === 40\n      /* LeftParenthesis */\n      && !isEscaped(selectorIndex)) {\n        counter++;\n      } else if (selector.charCodeAt(selectorIndex) === 41\n      /* RightParenthesis */\n      && !isEscaped(selectorIndex)) {\n        counter--;\n      }\n    }\n\n    if (counter) {\n      throw new Error(\"Parenthesis not matched\");\n    }\n\n    return unescapeCSS(selector.slice(start, selectorIndex - 1));\n  }\n\n  function isEscaped(pos) {\n    let slashCount = 0;\n\n    while (selector.charCodeAt(--pos) === 92\n    /* BackSlash */\n    ) slashCount++;\n\n    return (slashCount & 1) === 1;\n  }\n\n  function ensureNotTraversal() {\n    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n      throw new Error(\"Did not expect successive traversals.\");\n    }\n  }\n\n  function addTraversal(type) {\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {\n      tokens[tokens.length - 1].type = type;\n      return;\n    }\n\n    ensureNotTraversal();\n    tokens.push({\n      type\n    });\n  }\n\n  function addSpecialAttribute(name, action) {\n    tokens.push({\n      type: SelectorType.Attribute,\n      name,\n      action,\n      value: getName(1),\n      namespace: null,\n      ignoreCase: \"quirks\"\n    });\n  }\n  /**\n   * We have finished parsing the current part of the selector.\n   *\n   * Remove descendant tokens at the end if they exist,\n   * and return the last index, so that parsing can be\n   * picked up from here.\n   */\n\n\n  function finalizeSubselector() {\n    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {\n      tokens.pop();\n    }\n\n    if (tokens.length === 0) {\n      throw new Error(\"Empty sub-selector\");\n    }\n\n    subselects.push(tokens);\n  }\n\n  stripWhitespace(0);\n\n  if (selector.length === selectorIndex) {\n    return selectorIndex;\n  }\n\n  loop: while (selectorIndex < selector.length) {\n    const firstChar = selector.charCodeAt(selectorIndex);\n\n    switch (firstChar) {\n      // Whitespace\n      case 32\n      /* Space */\n      :\n      case 9\n      /* Tab */\n      :\n      case 10\n      /* NewLine */\n      :\n      case 12\n      /* FormFeed */\n      :\n      case 13\n      /* CarriageReturn */\n      :\n        {\n          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {\n            ensureNotTraversal();\n            tokens.push({\n              type: SelectorType.Descendant\n            });\n          }\n\n          stripWhitespace(1);\n          break;\n        }\n      // Traversals\n\n      case 62\n      /* GreaterThan */\n      :\n        {\n          addTraversal(SelectorType.Child);\n          stripWhitespace(1);\n          break;\n        }\n\n      case 60\n      /* LessThan */\n      :\n        {\n          addTraversal(SelectorType.Parent);\n          stripWhitespace(1);\n          break;\n        }\n\n      case 126\n      /* Tilde */\n      :\n        {\n          addTraversal(SelectorType.Sibling);\n          stripWhitespace(1);\n          break;\n        }\n\n      case 43\n      /* Plus */\n      :\n        {\n          addTraversal(SelectorType.Adjacent);\n          stripWhitespace(1);\n          break;\n        }\n      // Special attribute selectors: .class, #id\n\n      case 46\n      /* Period */\n      :\n        {\n          addSpecialAttribute(\"class\", AttributeAction.Element);\n          break;\n        }\n\n      case 35\n      /* Hash */\n      :\n        {\n          addSpecialAttribute(\"id\", AttributeAction.Equals);\n          break;\n        }\n\n      case 91\n      /* LeftSquareBracket */\n      :\n        {\n          stripWhitespace(1); // Determine attribute name and namespace\n\n          let name;\n          let namespace = null;\n\n          if (selector.charCodeAt(selectorIndex) === 124\n          /* Pipe */\n          ) {\n            // Equivalent to no namespace\n            name = getName(1);\n          } else if (selector.startsWith(\"*|\", selectorIndex)) {\n            namespace = \"*\";\n            name = getName(2);\n          } else {\n            name = getName(0);\n\n            if (selector.charCodeAt(selectorIndex) === 124\n            /* Pipe */\n            && selector.charCodeAt(selectorIndex + 1) !== 61\n            /* Equal */\n            ) {\n              namespace = name;\n              name = getName(1);\n            }\n          }\n\n          stripWhitespace(0); // Determine comparison operation\n\n          let action = AttributeAction.Exists;\n          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\n\n          if (possibleAction) {\n            action = possibleAction;\n\n            if (selector.charCodeAt(selectorIndex + 1) !== 61\n            /* Equal */\n            ) {\n              throw new Error(\"Expected `=`\");\n            }\n\n            stripWhitespace(2);\n          } else if (selector.charCodeAt(selectorIndex) === 61\n          /* Equal */\n          ) {\n            action = AttributeAction.Equals;\n            stripWhitespace(1);\n          } // Determine value\n\n\n          let value = \"\";\n          let ignoreCase = null;\n\n          if (action !== \"exists\") {\n            if (isQuote(selector.charCodeAt(selectorIndex))) {\n              const quote = selector.charCodeAt(selectorIndex);\n              let sectionEnd = selectorIndex + 1;\n\n              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {\n                sectionEnd += 1;\n              }\n\n              if (selector.charCodeAt(sectionEnd) !== quote) {\n                throw new Error(\"Attribute value didn't end\");\n              }\n\n              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n              selectorIndex = sectionEnd + 1;\n            } else {\n              const valueStart = selectorIndex;\n\n              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93\n              /* RightSquareBracket */\n              || isEscaped(selectorIndex))) {\n                selectorIndex += 1;\n              }\n\n              value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n            }\n\n            stripWhitespace(0); // See if we have a force ignore flag\n\n            const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20; // If the forceIgnore flag is set (either `i` or `s`), use that value\n\n            if (forceIgnore === 115\n            /* LowerS */\n            ) {\n              ignoreCase = false;\n              stripWhitespace(1);\n            } else if (forceIgnore === 105\n            /* LowerI */\n            ) {\n              ignoreCase = true;\n              stripWhitespace(1);\n            }\n          }\n\n          if (selector.charCodeAt(selectorIndex) !== 93\n          /* RightSquareBracket */\n          ) {\n            throw new Error(\"Attribute selector didn't terminate\");\n          }\n\n          selectorIndex += 1;\n          const attributeSelector = {\n            type: SelectorType.Attribute,\n            name,\n            action,\n            value,\n            namespace,\n            ignoreCase\n          };\n          tokens.push(attributeSelector);\n          break;\n        }\n\n      case 58\n      /* Colon */\n      :\n        {\n          if (selector.charCodeAt(selectorIndex + 1) === 58\n          /* Colon */\n          ) {\n            tokens.push({\n              type: SelectorType.PseudoElement,\n              name: getName(2).toLowerCase(),\n              data: selector.charCodeAt(selectorIndex) === 40\n              /* LeftParenthesis */\n              ? readValueWithParenthesis() : null\n            });\n            continue;\n          }\n\n          const name = getName(1).toLowerCase();\n          let data = null;\n\n          if (selector.charCodeAt(selectorIndex) === 40\n          /* LeftParenthesis */\n          ) {\n            if (unpackPseudos.has(name)) {\n              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\n                throw new Error(`Pseudo-selector ${name} cannot be quoted`);\n              }\n\n              data = [];\n              selectorIndex = parseSelector(data, selector, selectorIndex + 1);\n\n              if (selector.charCodeAt(selectorIndex) !== 41\n              /* RightParenthesis */\n              ) {\n                throw new Error(`Missing closing parenthesis in :${name} (${selector})`);\n              }\n\n              selectorIndex += 1;\n            } else {\n              data = readValueWithParenthesis();\n\n              if (stripQuotesFromPseudos.has(name)) {\n                const quot = data.charCodeAt(0);\n\n                if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {\n                  data = data.slice(1, -1);\n                }\n              }\n\n              data = unescapeCSS(data);\n            }\n          }\n\n          tokens.push({\n            type: SelectorType.Pseudo,\n            name,\n            data\n          });\n          break;\n        }\n\n      case 44\n      /* Comma */\n      :\n        {\n          finalizeSubselector();\n          tokens = [];\n          stripWhitespace(1);\n          break;\n        }\n\n      default:\n        {\n          if (selector.startsWith(\"/*\", selectorIndex)) {\n            const endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n\n            if (endIndex < 0) {\n              throw new Error(\"Comment was not terminated\");\n            }\n\n            selectorIndex = endIndex + 2; // Remove leading whitespace\n\n            if (tokens.length === 0) {\n              stripWhitespace(0);\n            }\n\n            break;\n          }\n\n          let namespace = null;\n          let name;\n\n          if (firstChar === 42\n          /* Asterisk */\n          ) {\n            selectorIndex += 1;\n            name = \"*\";\n          } else if (firstChar === 124\n          /* Pipe */\n          ) {\n            name = \"\";\n\n            if (selector.charCodeAt(selectorIndex + 1) === 124\n            /* Pipe */\n            ) {\n              addTraversal(SelectorType.ColumnCombinator);\n              stripWhitespace(2);\n              break;\n            }\n          } else if (reName.test(selector.slice(selectorIndex))) {\n            name = getName(0);\n          } else {\n            break loop;\n          }\n\n          if (selector.charCodeAt(selectorIndex) === 124\n          /* Pipe */\n          && selector.charCodeAt(selectorIndex + 1) !== 124\n          /* Pipe */\n          ) {\n            namespace = name;\n\n            if (selector.charCodeAt(selectorIndex + 1) === 42\n            /* Asterisk */\n            ) {\n              name = \"*\";\n              selectorIndex += 2;\n            } else {\n              name = getName(1);\n            }\n          }\n\n          tokens.push(name === \"*\" ? {\n            type: SelectorType.Universal,\n            namespace\n          } : {\n            type: SelectorType.Tag,\n            name,\n            namespace\n          });\n        }\n    }\n  }\n\n  finalizeSubselector();\n  return selectorIndex;\n}","map":null,"metadata":{},"sourceType":"module"}